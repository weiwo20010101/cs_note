## 进程和线程的区别 5`

1. 进程是资源分配的基本单位（包括内存，打开的文件），拥有的资源包括：代码段（内存中的代码），数据（运行时产生的数据），io资源（打开的文件描述符），线程是cpu调度的基本单位，共享进程的资源，比如内存，io，cpu。

2. 线程和进程相似，同样具有三种基本状态：就绪、阻塞、运行，同样具有状态之间的转换关系

   >补充java线程的五种状态
   >
   >新建状态  new Thread()
   >
   >就绪状态  ，线程对象被新建之后，其他线程调用了该对象的start()方法来启动线程。处于就绪状态的线程，随时可能被cpu调度调度执行
   >
   >运行
   >
   >阻塞
   >
   >结束

3 线程具有更高的并发性，能减少并发执行的时间和空间开销。具体体现在：

1. 线程创建比进程快，进程是资源分配的基本单位，需要创建大量资源管理元数据，而线程不需要关心，因为线程共享进程资源。（进程使用copy-on-write写时复制方式优化创建时间）
2. 线程切换快。进程切换是一个开销很大的操作，进行切换的开销包括：
   - cpu的上下文切换：保存和恢复寄存器的内容
   - 与进程相关的数据结构的更改：存储管理有关的信息（页表），文件管理有关数据（文件描述符），如果按照链接的方式组织pcb中的进程信息，按照状态分成各种队列，阻塞队列，就绪队列。（而线程只需要切换和cpu的上下文，不改变地址空间，不需要重新加载页表）
3. 线程终止也比较快，释放的资源比进程少。

4 线程之间的通信使用共享内存，进程之间的通信使用 IPC，Interprocess communication。

5 进程更健壮，多个进程之间不会互相干扰，一个线程出错会终止整个进程。

## PCB中的内容

- **Process State**：可以是running，waiting等。
- **进程 ID**和**父进程 ID**。
- CPU 寄存器和程序计数器。**程序计数器**保存该进程要执行的下一条指令的地址。
- **CPU调度**信息：比如优先级信息和指向调度队列的指针。
- **内存管理信息**：例如，页表或段表。
- **I/O 状态信息**：分配的设备、打开的文件表等。

## 进程的组成

1. 程序段，代码段
2. 数据段
3. pcb

从源码深入角度：

```c
struct task_struct {
	// 进程状态
	long			  state;
	// 虚拟内存结构体
	struct mm_struct  *mm;
	// 进程号
	pid_t			  pid;
	// 指向父进程的指针
	struct task_struct __rcu  *parent;
	// 子进程列表
	struct list_head		children;
	// 存放文件系统信息的指针
	struct fs_struct		*fs;
	// 一个数组，包含该进程打开的文件指针
	struct files_struct		*files;
};
```

files是一个文件指针数组，所有与（打开的文件和文件描述符）有关的信息都保存在其中。

一般来说，一个进程会从 `files[0]` 读取输入，将输出写入 `files[1]`，将错误信息写入 `files[2]`。

举个例子，以我们的角度 C 语言的 `printf` 函数是向命令行打印字符，但是从进程的角度来看，就是向 `files[1]` 写入数据；同理，`scanf` 函数就是进程试图从 `files[0]` 这个文件中读取数据。

**每个进程被创建时，`files` 的前三位被填入默认值，分别指向标准输入流、标准输出流、标准错误流。我们常说的「文件描述符」就是指这个文件指针数组的索引**，所以程序的文件描述符默认情况下 0 是输入，1 是输出，2 是错误。

![img](https://camo.githubusercontent.com/dd9656de09f3ecce07f360fe1c402961e8c3c3f3a67f912bbe688d11f7480bb3/68747470733a2f2f6c6162756c61646f6e672e67697465652e696f2f70696374757265732f6c696e757850726f636573732f322e6a7067)

对于一般的计算机，输入流是键盘，输出流是显示器，错误流也是显示器，所以现在这个进程和内核连了三根线。因为硬件都是由内核管理的，我们的进程需要通过「系统调用」让内核进程访问硬件资源。

## 线程的切换

**线程有自己的寄存器和栈，同时用线程ID标识**

![img](https://imageslr.com/media/15941873964798.jpg)

线程只需要切换处理机执行的上下文，不会改变地址空间。这意味着：

1. 不需要重新加载页表，切换开销少，提高效率
2. 多个线程共享地址空间，有利有弊

## 线程的优缺点

优点：

- 提高效率：切换开销小
- 通信方便，共享内存；进程必须通过IPC

缺点：

- 一个线程出错，操作系统会结束整个进程，不够健壮；而多进程就没有这个问题
- 同一进程中的多个线程共享内存，会有并发问题

## 线程进程的共享

首先要明确的是，多进程和多线程都是并发，都可以提高处理器的利用效率，所以现在的关键是，多线程和多进程有啥区别。

为什么说 Linux 中线程和进程基本没有区别呢，因为从 Linux 内核的角度来看，并没有把线程和进程区别对待。

我们知道系统调用 `fork()` 可以新建一个子进程，函数 `pthread()` 可以新建一个线程。**但无论线程还是进程，都是用 `task_struct` 结构表示的，唯一的区别就是共享的数据区域不同**。

换句话说，线程看起来跟进程没有区别，只是线程的某些数据区域和其父进程是共享的，而**子进程是拷贝副本**，而不是共享。就比如说，**`mm` 结构和 `files` 结构在线程中都是共享的**，我画两张图你就明白了：

![img](https://camo.githubusercontent.com/17d2bc85ca559c4a8dc10136dcf0804f48d193b7fd88a35a698987b3427fddaa/68747470733a2f2f6c6162756c61646f6e672e67697465652e696f2f70696374757265732f6c696e757850726f636573732f372e6a7067)

![img](https://camo.githubusercontent.com/f724d8e67cc0b9a9dfc09b8f09faa27e728d4afa00d61b68dcf6d77249fab965/68747470733a2f2f6c6162756c61646f6e672e67697465652e696f2f70696374757265732f6c696e757850726f636573732f382e6a7067)

所以说，我们的多线程程序要利用锁机制，避免多个线程同时往同一区域写入数据，否则可能造成数据错乱。

## 线程和协程的区别

一般来说，子程序调用是通过栈实现的，一个入口，一次返回，调用顺序是明确的，而协程的调用和子程序不同，协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。

第一大优势就是协程具有极高的执行效率，因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销。

第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。

因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。

另外：线程是抢占式的，而协程是非抢占的，也就是说同一个时间只能有一个协程运行，相当于单线程。协程也是具有自己的cpu寄存器和栈，在切换的时候将寄存器上下文和栈保存在线程的堆里面，在切回来的时候，恢复先前保存的寄存器上下文和栈。

线程进程可以看做是同步机制，而协程则是异步。

### 总结

1. 一个线程可以有多个协程。
2. 大多数业务场景下，线程进程可以看做是同步机制，而协程则是异步。
3. 线程是抢占式，而协程是非抢占式的，所以需要用户代码释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。
4. 协程并不是取代线程，而且抽象于线程之上。线程是被分割的CPU资源, 协程是组织好的代码流程, 协程需要线程来承载运行。

## 僵尸进程孤儿进程

进程由于某种原因终止 ----- 父进程回收已终止的子进程 ------ 内核抛弃进程，此时进程不再存在。

僵尸进程是指**终止但还未被回收**的进程。如果子进程退出，而父进程并没有调用 `wait()` 或 `waitpid()` 来回收，那么就会产生僵尸进程。僵尸进程是一个已经死亡的进程，但是其进程描述符仍然保存在系统的进程表中。

危害：占用进程号，系统所能使用的进程号是有限的，可能导致不能产生新的进程；占用一定的内存。

如何避免产生僵尸进程：

1. 父进程调用wait或者waitpid等待子进程结束
2. 在CSAPP中就提供了一个示例程序，在父进程注册信号处理函数，在该函数中调用waitpid，等待所有结束的子进程
3. 也可以进行系统调用忽略SIGCHLD信号，那么子进程结束后，内核会进行回收
4. 最直接的方式就是杀死父进程，僵尸进程就会变成孤儿进程，由init进程接管并且处理。

孤儿进程：

如果某个进程的父进程先结束了，那么它的子进程会成为孤儿进程每个进程结束的时候，系统都会扫描是否存在子进程，如果有则用 Init 进程（pid = 1）接管，并由 Init 进程调用 `wait` 等待其结束，完成状态收集工作。孤儿进程不会对系统造成危害。

## 进程间通信
| 方式     | 传输的信息量       | 使用场景       | 关键词                                                       |
| -------- | ------------------ | -------------- | ------------------------------------------------------------ |
| 信号     | 少量               | 任何           | 硬件来源、软件来源 / 信号队列                                |
| 管道     | 大量               | 亲缘进程间     | 单向流动 / 内核缓冲区 / 循环队列 / 没有格式的字节流 / 操作系统负责同步 |
| 命名管道 | 大量               | 任何           | 磁盘文件 / 访问权限 / 无数据块 / 内核缓冲区 / 操作系统负责同步 |
| 信号量   | N                  | 任何           | 互斥同步 / 原子性 / P 减 V 增                                |
| 共享内存 | 大量               | 多个进程       | 内存映射 / 简单快速 / 操作系统不保证同步                     |
| 消息队列 | 比信号多，但有限制 | 任何           | 有格式 / 按消息类型过滤 / 操作系统负责同步                   |
| 套接字   | 大量               | 不同主机的进程 | 读缓存区 / 写缓冲区 / 操作系统负责同步                       |
### 信号

由linux系统产生，被进程接收，接收到该信号的进程可以采取自定义的行为，这是一种“订阅-发布”模式。

来源：

- 硬件来源：比如按照ctrl+c，会发送sigint信号，按照ctri+z，会发送sigtstp（temporily stop）信号，除0，在x86机器上div指令除数为0时，会引发0号终端，编号#DE（Divide Error），即所谓的除零异常。这是一个硬件级别的终端，操作系统处理这个异常的方式就是：向进程发送一个信号sigfpe（浮点异常float point exception），如果进程设置的对应的signal handler，就执行进程的处理方法，否则操作系统的默认操作-杀死进程。
- 软件来源，比如kill命令

进程间如何使用信号通信？：

- 操作系统提供发送信号的系统调用
- 该系统调用会将信号放到目标进程的信号队列中
- 如果目标进程未处于运行状态，则该信号就由内核保存起来，直到该进程恢复执行并传递给它为止。如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。
- 发送信号时，必须指明发送目标进程的号码。一般用在具有亲缘关系的进程之间

进程如何接收信号？：

- 每个进程有一个信号队列，放其他进程发给它、等待它处理的信号
- 进程在执行过程中的特定时刻

用户进程对信号的处理过程有三种：

1. 处理信号。定义信号处理函数，当信号发生时，执行相应的处理函数
2. 忽略信号。当不希望接收到的信号对进程的执行产生影响，而让进程继续执行时，可以忽略该信号，即不对信号进程作任何处理
3. 不处理也不忽略。执行默认操作，linux 对每种信号都规定了默认操作

有的信号，用户进程是无法处理也无法忽略的，比如`SIGSTOP`、`SIGKILL` 等。

信号能传输的信息量很小，可以应用在任何场景。

### 管道/命名管道/消息队列

管道操作符｜的内部实现就是Linux的管道，分割的每个命令都是独立的进程，各个进程的标准输出时stdout，作为下一个进程的标准输入stdin。

### 定义：

管道是一种半双工的通信方式，数据只能**单向流动**，上游进程往管道中写入数据，下游进程从管道中接收数据。如果想实现双方通信，那么需要建立两个管道。

管道适合于**传输大量信息**。管道发送的内容是以字节为单位的，没有格式的**字节流**。

### 创建管道

通过 `pipe()` 系统调用来创建并打开一个管道，当最后一个使用它的进程关闭对他的引用时，pipe 将自动撤销。

通过 `pipe()` 创建的是匿名管道，只能用于具有亲缘关系的进程之间（父子进程或兄弟进程）。

### 管道的实现

**管道就是一个文件**，是一种只存在于内存中的特殊的文件系统。

管道是**由内核管理的一个缓冲区**，缓冲区被设计成为环形的数据结构，以便管道可以被循环利用（**循环队列**）。

### 管道的同步

管道是一个具有特定大小的缓冲区

- 操作系统会保证读写进程的同步
- 下游进程或者上游进程需要等另一方释放锁后才能操作管道。管道就相当于一个文件，同一时刻只能有一个进程访问
- 当管道为空时，下游进程读阻塞；当管道满时，上游进程写阻塞
- 管道不再被任何进程使用时，自动消失

### 命名管道FIFO

上面说的是匿名管道，只能用在亲缘进程中，管道文件信息保存在内存里。

### 指令

mknod（）

| **b** | 指示特殊文件是面向块的设备（磁盘、软盘或磁带）。 |
  | ----- | ------------------------------------------------ |
  | **C** | 表示特殊文件是面向字符的设备（其他设备）。       |
  | **p** | 创建 FIFO（命名管道）。                          |

mkfifo（）

建立命名管道时，会在磁盘中创建一个索引节点，命名管道的名字就相当于索引节点的文件名。索引节点设置了进程的访问权限，但是没有数据块。命名管道实质上也是通过**内核缓冲区**来实现数据传输。有访问权限的进程，可以通过磁盘的索引节点来读写这块缓冲区。

当不再被任何进程使用时，命名管道在内存中释放，但磁盘节点仍然存在。

### 信号量

信号量在底层的实现是通过硬件提供的原子指令，如 `Test And Set`、`Compare And Swap` 等。比如 golang 实现互斥量就是使用了 `Compare And Swap` 指令

### 共享内存

https://cloud.tencent.com/developer/article/1021157

共享内存顾名思义，允许两个或多个进程共享同一段物理内存。**不同进程可以将同一段共享内存映射到自己的地址空间，然后像访问正常内存一样访问它**。不同进程可以通过向共享内存端读写数据来交换信息。

**共享内存的优点是简单且高效**，访问共享内存区域和访问进程独有的内存区域一样**快**，原因是**不需要系统调用，不涉及用户态到内核态的转换，也不需要对数据不必要的复制**。

消息传递的实现经常采用系统调用，也就经常需要用户态和内核态互相转换；而共享内存只在建立共享内存区域时需要系统调用；一旦建立共享内存，所有访问都可作为常规内存访问，无需借助内核。

**共享内存的缺点是存在并发问题**，有可能出现多个进程修改同一块内存，因此共享内存一般与信号量结合使用。

### 消息队列

**消息队列是一个消息的链表**，保存在**内核**中。消息队列中的每个消息都是一个**数据块**，具有特定的格式。操作系统中可以存在多个消息队列，每个消息队列有唯一的 **key**，称为消息队列标识符。

消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。和信号相比，消息队列能够传递更多的信息。与管道相比，消息队列提供了**有格式**的数据，但消息队列仍然有大小限制。

消息队列允许一个或多个进程向它写入与读取消息。消息的发送者和接收者不需要同时与消息队列交互。消息会保存在队列中，直到接收者取回它。也就是说，消息队列是异步的，但这也造成了一个缺点，就是接收者必须**轮询**消息队列，才能收到最近的消息。

操作系统提供创建消息队列、取消息、发消息等系统调用。

操作系统负责读写同步：若消息队列已满，则写消息进程排队等待；若取消息进程没有找到需要的消息，则在等待队列中寻找。

消息队列和管道相比，相同点在于二者都是通过发送-接收的方式进行通信，并且数据都有最大长度限制。不同点在于消息队列的数据是有格式的，并且**取消息，进程可以选择接收特定类型的消息**，而不是像管道中那样默认全部接收。

## select/poll/epoll

### Select:

```
int select(int nfds,
            fd_set *restrict readfds,
            fd_set *restrict writefds,
            fd_set *restrict errorfds,
            struct timeval *restrict timeout);
```

`readfds`、`writefds`、`errorfds` 是三个文件描述符集合。`select` 会遍历每个集合的前 `nfds` 个描述符，分别找到可以读取、可以写入、发生错误的描述符，统称为“就绪”的描述符。然后用找到的子集替换参数中的对应集合，返回所有就绪描述符的总数。

`timeout` 参数表示调用 `select` 时的阻塞时长。如果所有文件描述符都未就绪，就阻塞调用进程，直到某个描述符就绪，或者阻塞超过设置的 timeout 后，返回。如果 `timeout` 参数设为 NULL，会无限阻塞直到某个描述符就绪；如果 `timeout` 参数设为 0，会立即返回，不阻塞。

例如：

比如进程想监听 1、2、5 这三个文件描述符，就将 `readFDs` 设置为 `00010011`，然后调用 `select`。

如果 `fd=1`、`fd=2` 就绪，而 `fd=5` 未就绪，`select` 会将 `readFDs` 设置为 `00000011` 并返回 2。

### 什么是文件描述符 fd

文件描述符（file descriptor）是一个非负整数，从 0 开始。进程使用文件描述符来标识一个打开的文件。

系统**为每一个进程维护了一个文件描述符表**，表示该进程打开文件的记录表，而**文件描述符实际上就是这张表的索引**。当进程打开（`open`）或者新建（`create`）文件时，内核会在该进程的文件列表中新增一个表项，同时返回一个文件描述符 —— 也就是新增表项的下标。

一般来说，每个进程最多可以打开 64 个文件，`fd ∈ 0~63`。在不同系统上，最多允许打开的文件个数不同，Linux 2.4.22 强制规定最多不能超过 1,048,576。

**每个进程默认都有 3 个文件描述符：0 (stdin)、1 (stdout)、2 (stderr)。**

### fd_set

参数中的 `fd_set` 类型表示文件描述符的集合。

由于文件描述符 `fd` 是一个从 0 开始的无符号整数，所以可以使用 `fd_set` 的**二进制每一位**来表示一个文件描述符。某一位为 1，表示对应的文件描述符已就绪。比如比如设 `fd_set` 长度为 1 字节，则一个 `fd_set` 变量最大可以表示 8 个文件描述符。当 `select` 返回 `fd_set = 00010011` 时，表示文件描述符 `1`、`2`、`5` 已经就绪。

`fd_set` 的使用涉及以下几个 API：

```c
#include <sys/select.h>   
int FD_ZERO(int fd, fd_set *fdset);  // 将 fd_set 所有位置 0
int FD_CLR(int fd, fd_set *fdset);   // 将 fd_set 某一位置 0
int FD_SET(int fd, fd_set *fd_set);  // 将 fd_set 某一位置 1
int FD_ISSET(int fd, fd_set *fdset); // 检测 fd_set 某一位是否为 1
```

### select的缺点

1. 性能开销大
   1. 调用 `select` 时会陷入内核，这时需要将参数中的 `fd_set` 从用户空间拷贝到内核空间
   2. 内核需要遍历传递进来的所有 `fd_set` 的每一位，不管它们是否就绪
2. 同时能够监听的文件描述符数量太少。受限于 `sizeof(fd_set)` 的大小，在编译内核时就确定了且无法更改。一般是 1024，不同的操作系统不相同

### poll

poll 和 select 几乎没有区别。poll 在用户态通过**数组**方式**传递**文件描述符，在内核会转为**链表**方式**存储**，没有最大数量的限制 。

poll 的函数签名如下：

```c
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
```

调用poll性能会比select高一点点，因为它指定了fds，比如指定为[1,4,5,8]，那么内核就只会遍历这几个，而调用select如果readfds/writefds/errorfds中同样指定了这四个文件描述符，比如 100110010，那么它会遍历所有的9个文件描述符，而不是poll的4个。

总结：

1. poll 性能好一点
2. poll使用数组方式存储文件描述符，并且没有最大数量的限制，同时监控的fd多，其他和select没啥区别。

### epoll

epoll 是对 select 和 poll 的改进，避免了“性能开销大”和“文件描述符数量少”两个缺点。

简而言之，epoll 有以下几个特点：

- 使用**红黑树**存储文件描述符集合
- 使用**队列**存储就绪的文件描述符
- 每个文件描述符只需在添加时传入一次；通过事件更改文件描述符状态

select、poll 模型都只使用一个函数，而 epoll 模型使用三个函数：`epoll_create`、`epoll_ctl` 和 `epoll_wait`。

#### 如何创建epoll实例

```c
int epoll_create(int size);
```

`epoll_create` 会创建一个 `epoll` 实例，同时返回一个引用该实例的文件描述符。

返回的文件描述符仅仅指向对应的 `epoll` 实例，并不表示真实的磁盘文件节点。其他 API 如 `epoll_ctl`、`epoll_wait` 会使用这个文件描述符来操作相应的 `epoll` 实例。

当创建好 epoll 句柄后，它会占用一个 fd 值，在 linux 下查看 `/proc/进程id/fd/`，就能够看到这个 fd。所以在使用完 epoll 后，必须调用 `close(epfd)` 关闭对应的文件描述符，否则可能导致 fd 被耗尽。当指向同一个 `epoll` 实例的所有文件描述符都被关闭后，操作系统会销毁这个 `epoll` 实例。

#### epoll 实例内部存储

- 监听列表：所有要监听的文件描述符，使用红黑树
- 就绪列表：所有就绪的文件描述符，使用链表

#### epoll_ctl

epoll_ctl会监听文件描述符fd上发生的event事件。

`epoll_ctl` 会监听文件描述符 `fd` 上发生的 `event` 事件。

参数说明：

- `epfd` 即 `epoll_create` 返回的文件描述符，指向一个 `epoll` 实例
- `fd` 表示要监听的目标文件描述符
- `event` 表示要监听的事件（可读、可写、发送错误…）
- `op `表示要对`fd`执行的操作，有以下几种：
  - `EPOLL_CTL_ADD`：为 `fd` 添加一个监听事件 `event`
  - `EPOLL_CTL_MOD`：Change the event event associated with the target file descriptor fd（`event` 是一个结构体变量，这相当于变量 `event` 本身没变，但是更改了其内部字段的值）
  - `EPOLL_CTL_DEL`：删除 `fd` 的所有监听事件，这种情况下 `event` 参数没用

返回值 0 或 -1，表示上述操作成功与否。

`epoll_ctl` 会将文件描述符 `fd` 添加到 `epoll` 实例的监听列表里，同时为 `fd` 设置一个回调函数，并监听事件 `event`。当 `fd` 上发生相应事件时，会调用回调函数，将 `fd` 添加到 `epoll` 实例的就绪队列上。

#### epoll_wait

```c
int epoll_wait(int epfd, struct epoll_event *events,
               int maxevents, int timeout);
```

这是 epoll 模型的主要函数，功能相当于 `select`。

参数说明：

- `epfd` 即 `epoll_create` 返回的文件描述符，指向一个 `epoll` 实例
- `events` 是一个数组，保存就绪状态的文件描述符，其空间由调用者负责申请
- `maxevents` 指定 `events` 的大小
- `timeout` 类似于 `select` 中的 timeout。如果没有文件描述符就绪，即就绪队列为空，则 `epoll_wait` 会阻塞 timeout 毫秒。如果 timeout 设为 -1，则 `epoll_wait` 会一直阻塞，直到有文件描述符就绪；如果 timeout 设为 0，则 `epoll_wait` 会立即返回

返回值表示 `events` 中存储的就绪描述符个数，最大不超过 `maxevents`。

### epoll 的优点

一开始说，epoll 是对 select 和 poll 的改进，避免了“性能开销大”和“文件描述符数量少”两个缺点。

对于“文件描述符数量少”，select 使用整型数组存储文件描述符集合，而 epoll 使用红黑树存储，数量较大。

对于“性能开销大”，`epoll_ctl` 中为每个文件描述符指定了回调函数，并在就绪时将其加入到就绪列表，因此 epoll 不需要像 `select` 那样遍历检测每个文件描述符，只需要判断就绪列表是否为空即可。这样，在没有描述符就绪时，epoll 能更早地让出系统资源。

> 相当于时间复杂度从 O(n) 降为 O(1)

此外，每次调用 `select` 时都需要向内核拷贝所有要监听的描述符集合，而 epoll 对于每个描述符，只需要在 `epoll_ctl` 传递一次，之后 `epoll_wait` 不需要再次传递。这也大大提高了效率。

### 水平触发、边缘触发

`select` 只支持水平触发，`epoll` 支持水平触发和边缘触发。

水平触发（LT，Level Trigger）：当文件描述符就绪时，会触发通知，如果用户程序没有一次性把数据读/写完，下次还会发出可读/可写信号进行通知。

边缘触发（ET，Edge Trigger）：仅当描述符从未就绪变为就绪时，通知一次，之后不会再通知。

区别：边缘触发效率更高，**减少了事件被重复触发的次数**，函数不会返回大量用户程序可能不需要的文件描述符。

> 水平触发、边缘触发的名称来源：数字电路当中的电位水平，高低电平切换瞬间的触发动作叫边缘触发，而处于高电平的触发动作叫做水平触发。

