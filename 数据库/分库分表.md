# 分库分表

https://www.infoq.cn/article/key-steps-and-likely-problems-of-horizontal-split-table

https://tech.meituan.com/2016/11/18/dianping-order-db-sharding.html

## 分布式ID

### 需求

全局唯一，趋势有序（如果id直接有序，则不必建立更多的索引，增加查询条件，而且Mysql innodb存储引擎主键使用的聚簇索引，主键有序则性能更高）。高可用，信息安全（比如敏感业务不能使用自增id，不能使用带有敏感信息生成的uuid，比如mac地址）。

### 方案

#### uuid

- 简单，生成性能好
- 无序，id无含义，字符串太长作为主键会影响性能
- 有重复几率

#### snowflake

snowflake是twitter开源的分布式ID生成算法，核心思想是：一个Long类型的ID,其中41bit作为毫秒数，10bit作为机器码，12bit作为毫秒内序列号。

优点：

- 毫秒数在高位，自增序列在低位，ID趋势递增。
- 以服务方式部署，可以做高可用。
- 根据业务分配bit位，灵活。

缺点：

- 每台机器的时钟不同，当时钟回拨可能会发生重复ID。
- 当数据量大的时候需要将id作为分片键分库分表，在跨毫秒时，序列号总是归0，会发生取模后分布不均衡。

#### 基于数据库flickr方案

##### 一般思路

结合数据库维护一个Sequence表：此方案的思路也很简单，在数据库中建立一个Sequence表，表的结构类似于：

```
CREATE TABLE `SEQUENCE` ( 
 
`tablename` varchar(30) NOT NULL, 
 
`nextid` bigint(20) NOT NULL, 
 
PRIMARY KEY (`tablename`) 
 
) ENGINE=InnoDB 
```

 

每当需要为某个表的新纪录生成ID时就从Sequence表中取出对应表的nextid,并将nextid的值加1后更新到数据库中以备下次使用。此方案也较简单，但缺点同样明显：由于所有插入任何都需要访问该表，该表很容易成为系统性能瓶颈，同时它也存在单点问题，一旦该表数据库失效，整个应用程序将无法工作。有人提出使用Master-Slave进行主从同步，但这也只能解决单点问题，并不能解决读写比为1:1的访问压力问题。

##### flickr方案

![img](https://s3.51cto.com/wyfs02/M00/9C/55/wKiom1lvFIWAOf00AABU5Yqb9dM714.jpg)

flickr这一方案的整体思想是：建立两台以上的数据库ID生成服务器，每个服务器都有一张记录各表当前ID的Sequence表，但是Sequence中ID增长的步长是服务器的数量，起始值依次错开，这样相当于把ID的生成散列到了每个服务器节点上。例如：如果我们设置两台数据库ID生成服务器，那么就让一台的Sequence表的ID起始值为1,每次增长步长为2,另一台的Sequence表的ID起始值为2,每次增长步长也为2，那么结果就是奇数的ID都将从***台服务器上生成，偶数的ID都从第二台服务器上生成，这样就将生成ID的压力均匀分散到两台服务器上，同时配合应用程序的控制，当一个服务器失效后，系统能自动切换到另一个服务器上获取ID，从而保证了系统的容错。

\1. flickr的数据库ID生成服务器是专用服务器，服务器上只有一个数据库，数据库中表都是用于生成Sequence的，这也是因为auto-increment-offset和auto-increment-increment这两个数据库变量是数据库实例级别的变量。

\2. flickr的方案中表格中的stub字段只是一个char(1) NOT NULL存根字段，并非表名，因此，一般来说，一个Sequence表只有一条纪录，可以同时为多张表生成ID，如果需要表的ID是有连续的，需要为该表单独建立Sequence表。

\3. 方案使用了MySQL的LAST_INSERT_ID()函数，这也决定了Sequence表只能有一条记录。

\4. 使用REPLACE INTO插入数据，这是很讨巧的作法，主要是希望利用mysql自身的机制生成ID,不仅是因为这样简单，更是因为我们需要ID按照我们设定的方式(初值和步长)来生成。

\5. SELECT LAST_INSERT_ID()必须要于REPLACE INTO语句在同一个数据库连接下才能得到刚刚插入的新ID，否则返回的值总是0

\6. 该方案中Sequence表使用的是MyISAM引擎，以获取更高的性能，注意：MyISAM引擎使用的是表级别的锁，MyISAM对表的读写是串行的，因此不必担心在并发时两次读取会得到同一个ID(另外，应该程序也不需要同步，每个请求的线程都会得到一个新的connection,不存在需要同步的共享资源)。经过实际对比测试，使用一样的Sequence表进行ID生成，MyISAM引擎要比InnoDB表现高出很多。

优点：

- 高可用，可容错，负载均衡，避免单点问题
- id较简洁

感觉不太好

- 水平拓展困难，因为步数和机器数相同，如果机器挂了，那么步数也要进行修改
- 依赖数据库，需要多个数据集id生成服务器，每个服务器都有一张记录各表当前id的sequence表。

#### 基于业务

比如对于订单系统，参考雪花算法：

![image-20230221194239348](/Users/bytedance/Library/Application Support/typora-user-images/image-20230221194239348.png)

## 数据迁移

需要

- 新数据双写，旧数据同步，校验新旧数据

- 历史数据导入完成之后，依旧双写，而查询切新数据源，每日新旧数据库数据校验

- 老数据源不再同步与写入，逐渐废除老模型

## 总结

并非所有表都需要水平拆分，要看增长的类型和速度，水平拆分是大招，拆分后会增加开发的复杂度，不到万不得已不使用。

在大规模并发的业务上，尽量做到在线查询和离线查询隔离，交易查询和运营/客服查询隔离。

拆分维度的选择很重要，要尽可能在解决拆分前问题的基础上，便于开发。

数据库没你想象的那么坚强，需要保护，尽量使用简单的、良好索引的查询，这样数据库整体可控，也易于长期容量规划以及水平扩展。

  

