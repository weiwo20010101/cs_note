# 分库分表

https://www.infoq.cn/article/key-steps-and-likely-problems-of-horizontal-split-table

https://tech.meituan.com/2016/11/18/dianping-order-db-sharding.html

## 分布式ID

### 需求

全局唯一，趋势有序（如果id直接有序，则不必建立更多的索引，增加查询条件，而且Mysql innodb存储引擎主键使用的聚簇索引，主键有序则性能更高）。高可用，信息安全（比如敏感业务不能使用自增id，不能使用带有敏感信息生成的uuid，比如mac地址）。

### 方案

#### uuid

- 简单，生成性能好
- 无序，id无含义，字符串太长作为主键会影响性能
- 有重复几率

#### snowflake

snowflake是twitter开源的分布式ID生成算法，核心思想是：一个Long类型的ID,其中41bit作为毫秒数，10bit作为机器码，12bit作为毫秒内序列号。

优点：

- 毫秒数在高位，自增序列在低位，ID趋势递增。
- 以服务方式部署，可以做高可用。
- 根据业务分配bit位，灵活。

缺点：

- 每台机器的时钟不同，当时钟回拨可能会发生重复ID。
- 当数据量大的时候需要将id作为分片键分库分表，在跨毫秒时，序列号总是归0，会发生取模后分布不均衡。

#### 基于数据库flickr方案

这个方案的思路时采用了MySQL自增长ID的机制（auto_increment+auto_increment_offset）。

通过使用以下SQL获取不同的ID:

```sql
begin;
REPLACE INTO Tickets64 (stub) VALUES ('a');
SELECT LAST_INSERT_ID();
commit;
```

在分布式系统中，多部署几台Mysql，每台机器的初始值不同，步数与机器数量相等。
假设部署N台机器，步数为N,每台机器初始值依次为：0、1、2...N-1，架构如下：

![preview](https://segmentfault.com/img/remote/1460000021175385/view)

优点：

- 高可用
- id较简洁

感觉不太好

- 水平拓展困难，因为步数和机器数相同
- 依赖数据库，需要单独的数据库集群

#### 基于业务

比如对于订单系统，参考雪花算法：

![image-20230221194239348](/Users/bytedance/Library/Application Support/typora-user-images/image-20230221194239348.png)

## 数据迁移

需要

- 新数据双写，旧数据同步，校验新旧数据

- 历史数据导入完成之后，依旧双写，而查询切新数据源，每日新旧数据库数据校验

- 老数据源不再同步与写入，逐渐废除老模型

## 总结

并非所有表都需要水平拆分，要看增长的类型和速度，水平拆分是大招，拆分后会增加开发的复杂度，不到万不得已不使用。

在大规模并发的业务上，尽量做到在线查询和离线查询隔离，交易查询和运营/客服查询隔离。

拆分维度的选择很重要，要尽可能在解决拆分前问题的基础上，便于开发。

数据库没你想象的那么坚强，需要保护，尽量使用简单的、良好索引的查询，这样数据库整体可控，也易于长期容量规划以及水平扩展。

  

